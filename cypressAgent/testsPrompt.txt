\
# Cypress E2E Testing Guidelines for React Applications

## General Principles

*   **Goal:** Write reliable, readable, and maintainable end-to-end tests that simulate real user interactions with the React application.
*   **Focus:** Test user flows and critical paths, ensuring components integrate correctly and the application behaves as expected from a user's perspective.
*   **Flake Resistance & Retry-ability:** Leverage Cypress's core feature: automatic waiting and retry-ability. Cypress commands query the DOM and retry assertions until they pass or time out (`defaultCommandTimeout`). Trust Cypress to wait for elements to exist, become visible, actionable, and for assertions to pass. **Avoid manual waits (`cy.wait(Number)`)**.
*   **Debuggability:** Utilize the Cypress Test Runner's UI, time-traveling snapshots, and browser DevTools for efficient debugging.

## Test Structure & Organization

*   **Structure:** Use Mocha's `describe()` for grouping tests (suites) and `it()` for individual test cases. Use `context()` as an alias for `describe()` if preferred.
*   **Hooks:**
    *   Use `beforeEach()` to set up common preconditions *and* clean up state *before* tests run (e.g., visiting a page, seeding data via API/task, logging in programmatically, resetting DB state). This ensures test independence and debuggability.
    *   Use `before()` for one-time setup for a suite (use cautiously, ensure it doesn't create inter-test dependencies).
*   **Cleanup:** **Avoid using `after()` or `afterEach()` for state cleanup.** If a test fails or is interrupted (e.g., refreshing the runner), these hooks may not run, leaving residual state that affects subsequent tests. Clean up state *before* tests in `beforeEach()`.
*   **Test Isolation:** Ensure each test can run independently (`it.only(...)`) and pass. Do not rely on the state generated by previous tests. Reset state in `beforeEach`. Combine related steps into a single, larger test if they represent one user flow, rather than creating dependencies between `it()` blocks.
*   **File Organization:** Group tests logically by feature or page in separate spec files within the `cypress/e2e` directory (or configured spec directory).

## Selecting Elements

*   **Best Practice:** Use dedicated `data-cy` or `data-testid` attributes on elements for stable, resilient selectors. This decouples tests from CSS changes or JS implementation details.
    *   Example: `cy.get('[data-cy="submit-button"]')`
*   **Avoid Brittle Selectors:** Do not rely heavily on CSS classes, IDs, tag names, or text content that might change frequently.
*   **`cy.contains()`:** Use `cy.contains()` when the text content of an element is *critical* for the test itself (i.e., the test *should* fail if the text changes). Be mindful that this couples the test to the text content.
    *   Example: `cy.contains('button', 'Submit Form')`
*   **Readability:** Consider custom commands like `getBySel` for cleaner tests if using `data-test` attributes frequently.
*   **Testing Library:** `cypress-testing-library` offers alternative selectors (e.g., `findByRole`, `findByLabelText`) that align with accessibility principles. Use them if your team prefers this approach, but understand they don't replace explicit accessibility testing.

## Interacting with Elements

*   **Actionability:** Cypress automatically waits for elements to be "actionable" (visible, not disabled, not covered, not animating, etc.) before interacting (e.g., `.click()`, `.type()`). Trust this mechanism.
*   **Chaining:**
    *   Chain commands logically off `cy` or element queries.
    *   **End chains after actions:** Start new chains (`cy.get(...)`) after actions like `.click()` or `.type()` that might cause the DOM to re-render. This prevents operating on stale elements.
    *   Incorrect: `cy.get('input').type('text').should('have.class', 'active')` (Assertion might run on stale element if `type` causes re-render)
    *   Correct: `cy.get('input').type('text'); cy.get('input').should('have.class', 'active')`
    *   Use aliases (`.as()`) to reference elements across chains reliably.
*   **Typing:** Use `.type()` to simulate user input.
*   **Clicking:** Use `.click()` to simulate clicks. Cypress handles ensuring the element is clickable.
*   **Force:** Use `{ force: true }` sparingly. Only use it when Cypress's actionability checks genuinely prevent interaction with an element that *should* be interactable (and you understand why), or when bypassing complex UI interactions (like intricate hover menus) is necessary and acceptable for the test's goal. It often masks underlying issues.

## Assertions

*   **Implicit Assertions:** Rely on Cypress's built-in assertions within commands (e.g., `cy.get()` expects the element to exist, `.click()` expects it to be actionable). You often don't need explicit `.should('exist')` or `.should('be.visible')`.
*   **Explicit Assertions:** Use `.should()` or `.and()` to assert specific states or properties. Leverage bundled Chai, Chai-jQuery, and Sinon-Chai assertions.
    *   Example: `cy.get('li.todo').should('have.length', 3)`
    *   Example: `cy.get('input[type="email"]').should('have.value', 'test@example.com')`
    *   Example: `cy.get('.error-message').should('be.visible').and('contain', 'Invalid input')`
*   **Retry-ability:** Assertions automatically retry (with the preceding query chain) until they pass or the command times out. Describe the *desired state*, and let Cypress wait for it.
*   **Multiple Assertions:**
    *   Chain multiple assertions using `.and()` for the *same* element state.
    *   For assertions on *different* states of the same element (e.g., visible then not visible), re-query the element between assertions: `cy.get(selector).should('be.visible'); cy.get(selector).should('not.be.visible');`
*   **Callback Functions (`.should(callbackFn)`):** Use for complex assertions involving multiple elements or custom logic. Ensure the callback is idempotent (safe to retry). Cypress retries the entire callback.
    ```javascript
    cy.get('[data-testid="random-number"]').should(($div) => {
      // This entire function retries
      const n = parseFloat($div.text());
      expect(n).to.be.gte(1).and.be.lte(10);
    });
    ```
*   **Negative Assertions (`.should('not.exist')`, etc.):** Use with caution. Ensure they don't pass for unintended reasons (e.g., asserting an element *doesn't* have a class might pass if the element doesn't even exist). Positive assertions are often more robust.

## Handling Asynchronicity

*   **Commands are Asynchronous:** Cypress commands are enqueued and executed sequentially. You cannot assign their return values to variables directly (`const el = cy.get(...)` won't yield the element).
*   **Closures (`.then()`):** Use `.then()` to access the value yielded by the previous command *when you need to work with that value directly* (e.g., perform calculations, comparisons). `.then()` breaks the retry chain for preceding commands.
    ```javascript
    cy.get('.counter').invoke('text').then(parseInt).then((count1) => {
      cy.contains('button', 'Increment').click();
      // Re-query and use .should() for retry-ability
      cy.get('.counter').invoke('text').then(parseInt).should('eq', count1 + 1);
    });
    ```
*   **Aliases (`.as()` and `@`):** Use aliases to store and share references to elements, requests, or data, especially between hooks (`beforeEach`) and tests (`it`), or across action commands. Access aliases using `cy.get('@aliasName')`.
    *   Example (Elements):
        ```javascript
        cy.get('nav > ul > li').as('menuItems');
        // ... later ...
        cy.get('@menuItems').should('have.length', 5); // Re-queries the element
        ```
    *   Example (Data):
        ```javascript
        beforeEach(() => {
          cy.fixture('user.json').as('userData');
        });
        it('uses user data', function() { // Use function() for `this` context or cy.get('@...')
          cy.get('@userData').then(userData => {
             cy.get('input[name="name"]').type(userData.name);
          });
        });
        ```
*   **Retry-ability with Aliases:** When referencing element aliases with `cy.get('@aliasName')`, Cypress re-runs the original query chain, helping to avoid stale elements.

## Network Requests (`cy.intercept()`)

*   **Strategy:** Decide whether to use real server responses (true e2e) or stub responses (`cy.intercept()`).
    *   **Real Responses:** Good for critical paths (login, signup, core features) to verify client-server contract. Slower, requires backend state management (seeding). Use sparingly, perhaps one happy path test per feature.
    *   **Stub Responses:** Faster, reliable, allows easy testing of edge cases, loading states, and error conditions without backend dependencies. Ideal for most component interactions and UI states. Use fixtures (`{ fixture: '...' }`) for response bodies.
*   **`cy.intercept()`:** Define intercepts to spy on (`.as()`), stub (`{ fixture: '...' }`, `{ body: ... }`), or modify network requests (XHR/fetch). Define intercepts *before* the action that triggers the request.
*   **Waiting (`cy.wait('@alias')`):** Alias intercepts (`.as('aliasName')`) and use `cy.wait('@aliasName')` to explicitly wait for requests to complete before proceeding or asserting. This is crucial for reliability when UI updates depend on network responses.
    *   Example:
        ```javascript
        cy.intercept('POST', '/api/users').as('createUser');
        cy.get('form').submit();
        cy.wait('@createUser').its('response.statusCode').should('eq', 201);
        // Assert on request/response data
        cy.get('@createUser').should(({ request, response }) => {
           expect(request.body).to.include({ name: 'Test User' });
           expect(response.body).to.have.property('id');
        });
        ```
*   **GraphQL:** Use helper functions with `cy.intercept()` to match GraphQL operations by `operationName` in the request body and alias them for waiting and assertion.
    ```javascript
    // Example helper
    const hasOperationName = (req, operationName) => req.body.operationName === operationName;

    // In test or beforeEach
    cy.intercept('POST', '/graphql', (req) => {
      if (hasOperationName(req, 'GetUser')) {
        req.alias = 'gqlGetUserQuery';
        // Optionally modify response: req.reply(res => ...)
      }
    });
    // Later in test
    cy.wait('@gqlGetUserQuery').its('response.body.data.user.name').should('eq', 'Jane');
    ```

## State Management & Login

*   **Programmatic Login:** Log users in programmatically for most tests to save time and improve reliability. Avoid logging in through the UI in every test. Test the UI login flow thoroughly in *one* dedicated test.
    *   **API Login (`cy.request()`):** Preferred method. Use `cy.request()` to interact with your login API directly, get session tokens/cookies, and set them in the browser.
    *   **`cy.session()`:** Cache and restore browser state (cookies, localStorage, sessionStorage) across tests for a given login flow. Significantly speeds up tests that require login. Use in combination with API or UI login logic.
        ```javascript
        Cypress.Commands.add('login', (username, password) => {
          cy.session([username, password], () => {
            // This code runs only once per unique [username, password]
            cy.request({
              method: 'POST',
              url: '/api/login',
              body: { username, password },
            }).then(({ body }) => {
              // Set tokens/cookies based on response if needed
              window.localStorage.setItem('token', body.token);
            });
          }, {
            validate() { // Optional: Check if session is still valid
              cy.request('/api/me').its('status').should('eq', 200);
            }
          });
        });
        ```
    *   **`cy.origin()`:** Use when the login flow involves navigating to a different origin (domain, subdomain, or port) that you control (e.g., SSO provider). Execute Cypress commands on that origin within the callback. Often used with `cy.session()`.
*   **Data Seeding/Stubbing:**
    *   **Seeding:** Use `cy.task()` or `cy.exec()` in `beforeEach` to run backend scripts (Node.js, shell scripts) that reset/seed the database for tests requiring real data.
    *   **Stubbing:** Use `cy.intercept()` with fixtures or static responses for tests that don't need a real backend response.
*   **Control Application State:** Use application-specific methods (if available via `window`), backend APIs (`cy.request()`, `cy.task()`), or URL parameters to put the application into a specific state *before* a test, rather than relying solely on UI interactions.

## Configuration (`cypress.config.js` or `.ts`)

*   **`baseUrl`:** Set the `baseUrl` (e.g., `http://localhost:3000`). Allows using relative paths in `cy.visit('/')` and `cy.request('/api/users')`, making tests more portable and slightly faster to start.
*   **Timeouts:**
    *   `defaultCommandTimeout`: (Default: 4000ms) Adjust globally only if necessary, prefer per-command timeouts.
    *   Per-command: Use `{ timeout: ms }` for specific commands that genuinely take longer (e.g., waiting for a long async operation). `cy.get('.slow-element', { timeout: 10000 }).should('be.visible');`

## Conditional Testing

*   **Avoid Relying on DOM State:** Do **not** write tests like `if (cy.get(selector).should('exist')) { ... } else { ... }` based on potentially changing DOM elements. Web apps are asynchronous; the element might appear/disappear *after* your check, leading to flaky tests. Cypress commands are not designed for traditional `if/else` control flow based on their success/failure.
*   **Stable Sources of Truth:** If conditional logic is unavoidable, base it on stable information *before* interacting with the potentially conditional UI:
    *   URL parameters (`cy.url().should('include', '...')`)
    *   Data from API responses (`cy.wait('@getData').then(...)`)
    *   Cookies (`cy.getCookie('featureFlag').then(...)`)
    *   Static data attributes embedded in the HTML (`cy.get('html[data-feature-x="true"]')`)
*   **Error Recovery:** Cypress does **not** support `try/catch` around commands to recover from failures. A failed command stops the test. Design tests to be deterministic.

## Avoid Anti-Patterns

*   **No `cy.wait(Number)`:** Don't use arbitrary waits. Use assertions, `cy.wait('@alias')`, or increase command timeouts if needed.
*   **No Conditional Testing on Unstable DOM:** Avoid `if/else` logic based on DOM elements unless you are 100% certain the DOM state is stable *at that exact moment* (rare in modern apps).
*   **No `after/afterEach` for Cleanup:** Clean state in `beforeEach`.
*   **Test Independence:** Ensure tests don't depend on each other. Use `it.only` to verify.
*   **Don't Assign Command Results:** Use `.then()` or aliases (`.as()`, `@`).
*   **Avoid External Sites via UI:** Don't test sites you don't control directly in the browser (`cy.visit('google.com')`). Use `cy.request()` for API interactions if needed. Use `cy.origin()` only for cross-origin sites *you control*.
*   **Don't Chain After Actions:** Start new chains after commands like `.click()`, `.type()`, etc.
*   **Tiny Tests:** Avoid creating tests with only a single assertion if they belong to the same logical flow. Group related assertions within one `it()` block for better performance (less state resetting).

## Accessibility (A11y)

*   **Importance:** Ensure your application is usable by people with disabilities.
*   **Strategies:**
    *   **Automated Scans:** Use plugins like `cypress-axe` to run checks (`cy.checkA11y()`) against WCAG rules within your tests. Be mindful of performance impact; run scans strategically (e.g., after major state changes, not necessarily on every action).
    *   **Explicit Tests:** Write specific assertions for accessibility requirements (e.g., `cy.get('img').should('have.attr', 'alt', 'Descriptive text')`, `cy.get('button').focus().type('{enter}')`).
    *   **Keyboard Navigation:** Test keyboard interactions using `.focus()`, `.tab()`, `.type('{enter}')`, etc.
*   **Locators:** While `data-*` attributes are good for stability, consider using accessibility-focused locators (like those from `cypress-testing-library`) where appropriate, but remember they don't guarantee accessibility on their own.
